
import java.awt.Color;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author raveen
 */
public class MyPathFinder extends javax.swing.JFrame {

    // this arraylist is used to store the nodes in which the algorithm visit.
    ArrayList<GraphNode> openList = new ArrayList<GraphNode>();

    // this arraylist is used to store the nodes in the openList that has the minimum fCost.
    ArrayList<GraphNode> closeList = new ArrayList<GraphNode>();

    ArrayList<GraphNode> path = new ArrayList<GraphNode>();

    // this arraylist is used to store the adjacent nodes of the currentNode
    ArrayList<GraphNode> adjacentNodesList = new ArrayList<GraphNode>();

    private int x_origin;
    private int y_origin;
    private int x_desti;
    private int y_desti;

    // decklaring the 2d array. This array is used to store the weight of the each cell of the grid.
    private int imageGrid[][];

    // the size of elements in one side of the grid.
    private final int N = 20;

    public MyPathFinder() {
        initComponents();
        generateTheGrid();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField2 = new javax.swing.JTextField();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        txt_origin_x = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        txt_origin_y = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        txt_desti_x = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        txt_desti_y = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        CBMethod = new javax.swing.JComboBox();
        lblTopic = new javax.swing.JLabel();
        lblCoordinates = new javax.swing.JLabel();
        lblOriginCoordinates = new javax.swing.JLabel();
        lblDestiCoordinates = new javax.swing.JLabel();
        lblTotalCostTopic = new javax.swing.JLabel();
        lblHMethodTopic = new javax.swing.JLabel();
        lblHMethod = new javax.swing.JLabel();
        lblTotalCost = new javax.swing.JLabel();

        jTextField2.setText("jTextField2");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("---Enter the Co-ordinates---");

        jLabel2.setText("Origination (Blue)");

        jLabel3.setText("X");

        jLabel4.setText(":");

        jLabel5.setText("Y");

        jLabel6.setText("Destination (Green)");

        jLabel7.setText("X");

        jLabel8.setText(":");

        jLabel9.setText("Y");

        jButton1.setText("Find Path");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel10.setText("Path Finding App");

        jLabel11.setText("---Select The Path Finding Method---");

        CBMethod.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Euclidean", "Manhattan", "Chebyshev" }));

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jLabel10)
                .addGap(125, 125, 125))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(20, 20, 20)
                                .addComponent(jLabel7)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txt_desti_x, javax.swing.GroupLayout.PREFERRED_SIZE, 117, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel8)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel9)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txt_desti_y, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel11)
                            .addComponent(jLabel6))
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(42, 42, 42)
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txt_origin_x, javax.swing.GroupLayout.PREFERRED_SIZE, 117, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel5)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txt_origin_y, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(22, 22, 22)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel1)
                                    .addComponent(jLabel2)))))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(127, 127, 127)
                        .addComponent(CBMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(106, 106, 106)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 160, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(41, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel10)
                .addGap(10, 10, 10)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txt_origin_x, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4)
                    .addComponent(jLabel5)
                    .addComponent(txt_origin_y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txt_desti_x, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel7)
                    .addComponent(jLabel8)
                    .addComponent(jLabel9)
                    .addComponent(txt_desti_y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(31, 31, 31)
                .addComponent(jLabel11)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(CBMethod, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(26, 26, 26)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(76, Short.MAX_VALUE))
        );

        lblTopic.setText("Path Information");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(128, 128, 128)
                        .addComponent(lblTopic))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(62, 62, 62)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblDestiCoordinates)
                            .addComponent(lblOriginCoordinates)))
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblTotalCostTopic)
                            .addComponent(lblCoordinates)
                            .addComponent(lblHMethodTopic)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(60, 60, 60)
                        .addComponent(lblHMethod))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(60, 60, 60)
                        .addComponent(lblTotalCost)))
                .addGap(123, 123, 123))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblTopic)
                        .addGap(24, 24, 24)
                        .addComponent(lblCoordinates)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblOriginCoordinates)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(lblDestiCoordinates)
                        .addGap(39, 39, 39)
                        .addComponent(lblHMethodTopic)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblHMethod)
                        .addGap(39, 39, 39)
                        .addComponent(lblTotalCostTopic)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblTotalCost))
                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed

        if (txt_origin_x.getText().equals("")) {
            JOptionPane.showMessageDialog(null, "Please Enter the X Coordinate for the Begining Cell");
        } else if (txt_origin_y.getText().equals("")) {
            JOptionPane.showMessageDialog(null, "Please Enter the Y Coordinate for the Begining Cell");
        } else if (txt_desti_x.getText().equals("")) {
            JOptionPane.showMessageDialog(null, "Please Enter the X Coordinate for the Destination Cell");
        } else if (txt_desti_y.getText().equals("")) {
            JOptionPane.showMessageDialog(null, "Please Enter the Y Coordinate for the Destination Cell");
        } else {
            int user_defined_x_origin = Integer.parseInt(txt_origin_x.getText());
            int user_defined_y_origin = Integer.parseInt(txt_origin_y.getText());

            int user_defined_x_desti = Integer.parseInt(txt_desti_x.getText());
            int user_defined_y_desti = Integer.parseInt(txt_desti_y.getText());

            if (user_defined_x_origin < 0 || user_defined_x_origin > 19) {
                JOptionPane.showMessageDialog(null, "Please Enter the X Coordinate between 0 and 19 inclusive");
            } else if (user_defined_y_origin < 0 || user_defined_y_origin > 19) {

                JOptionPane.showMessageDialog(null, "Please Enter the Y Coordinate between 0 and 19 inclusive");

            } else if (user_defined_x_desti < 0 || user_defined_x_desti > 19) {

                JOptionPane.showMessageDialog(null, "Please Enter the X Coordinate between 0 and 19 inclusive");

            } else if (user_defined_y_desti < 0 || user_defined_y_desti > 19) {

                JOptionPane.showMessageDialog(null, "Please Enter the Y Coordinate between 0 and 19 inclusive");

            } else if (imageGrid[user_defined_x_origin][user_defined_y_origin] == 5) {

                JOptionPane.showMessageDialog(null, "The origination coordinates you entered cannot be considered since it is an obstacle."
                        + "\n Please Enter your origination coordinates again");

            } else if (imageGrid[user_defined_x_desti][user_defined_y_desti] == 5) {

                JOptionPane.showMessageDialog(null, "The destination coordinates you entered cannot be considered since it is an obstacle."
                        + "\nPlease Enter your destination coordinates again");

            } else {
                
                String user_selected_method = CBMethod.getSelectedItem().toString();

                showThePath(user_defined_x_origin, user_defined_y_origin, user_defined_x_desti, user_defined_y_desti, user_selected_method);
                
                
            }
        }


    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    private void generateTheGrid() {
        // creating the 20 x 20 grid.
        imageGrid = new int[N][N];

        // Setting the weight of all the cells in the grid to 1.
        for (int i = 0; i < imageGrid.length; i++) {
            for (int j = 0; j < imageGrid.length; j++) {
                imageGrid[j][i] = 1;
            }
        }

        // Setting the value of 2d element according to the weights of the grid. 
        // Setting the cells that has the weight 2
        imageGrid[10][19] = 2;
        imageGrid[12][19] = 2;
        imageGrid[7][18] = 2;
        imageGrid[8][18] = 2;
        imageGrid[9][18] = 2;
        imageGrid[10][18] = 2;
        imageGrid[11][18] = 2;
        imageGrid[12][18] = 2;
        imageGrid[8][17] = 2;
        imageGrid[12][17] = 2;
        imageGrid[8][16] = 2;
        imageGrid[13][16] = 2;
        imageGrid[8][15] = 2;
        imageGrid[9][15] = 2;
        imageGrid[13][15] = 2;
        imageGrid[9][14] = 2;
        imageGrid[10][14] = 2;
        imageGrid[11][14] = 2;
        imageGrid[12][14] = 2;
        imageGrid[13][14] = 2;
        imageGrid[1][12] = 2;
        imageGrid[1][13] = 2;
        imageGrid[2][11] = 2;
        imageGrid[3][12] = 2;
        imageGrid[5][11] = 2;
        imageGrid[6][11] = 2;
        imageGrid[6][10] = 2;
        imageGrid[7][10] = 2;
        imageGrid[7][9] = 2;
        imageGrid[5][9] = 2;
        imageGrid[4][9] = 2;
        imageGrid[3][9] = 2;
        imageGrid[2][8] = 2;
        imageGrid[1][8] = 2;
        imageGrid[1][9] = 2;
        imageGrid[1][10] = 2;
        imageGrid[16][9] = 2;

        // Setting the cells that has the weight 2
        imageGrid[15][14] = 2;
        imageGrid[16][14] = 2;
        imageGrid[17][14] = 2;
        imageGrid[16][15] = 2;
        imageGrid[17][15] = 2;
        imageGrid[15][13] = 2;
        imageGrid[16][13] = 2;
        imageGrid[4][14] = 2;
        imageGrid[5][14] = 2;
        imageGrid[4][13] = 2;
        imageGrid[5][13] = 2;
        imageGrid[0][2] = 2;
        imageGrid[1][2] = 2;
        imageGrid[1][3] = 2;
        imageGrid[2][3] = 2;
        imageGrid[3][3] = 2;
        imageGrid[4][3] = 2;
        imageGrid[5][3] = 2;
        imageGrid[9][3] = 2;
        imageGrid[10][4] = 2;
        imageGrid[10][5] = 2;
        imageGrid[9][5] = 2;

        // Setting the cells that has the weight 3
        imageGrid[9][17] = 3;
        imageGrid[10][17] = 3;
        imageGrid[11][17] = 3;
        imageGrid[9][16] = 3;
        imageGrid[10][16] = 3;
        imageGrid[11][16] = 3;
        imageGrid[12][16] = 3;
        imageGrid[10][15] = 3;
        imageGrid[11][15] = 3;
        imageGrid[12][15] = 3;
        imageGrid[3][11] = 3;
        imageGrid[4][11] = 3;
        imageGrid[2][10] = 3;
        imageGrid[3][10] = 3;
        imageGrid[4][10] = 3;
        imageGrid[5][10] = 3;
        imageGrid[2][9] = 3;
        imageGrid[6][9] = 3;

        // Setting the cells that has the weight 4
        imageGrid[19][12] = 4;
        imageGrid[18][12] = 4;
        imageGrid[19][11] = 4;
        imageGrid[18][11] = 4;
        imageGrid[17][11] = 4;

        imageGrid[12][10] = 4;
        imageGrid[13][10] = 4;
        imageGrid[14][10] = 4;
        imageGrid[15][10] = 4;
        imageGrid[16][10] = 4;
        imageGrid[17][10] = 4;
        imageGrid[18][10] = 4;

        imageGrid[12][9] = 4;
        imageGrid[13][9] = 4;
        imageGrid[14][9] = 4;
        imageGrid[15][9] = 4;

        imageGrid[12][8] = 4;
        imageGrid[13][8] = 4;
        imageGrid[14][8] = 4;

        imageGrid[6][8] = 4;
        imageGrid[7][8] = 4;
        imageGrid[8][8] = 4;
        imageGrid[9][8] = 4;

        imageGrid[2][7] = 4;
        imageGrid[3][7] = 4;
        imageGrid[4][7] = 4;
        imageGrid[5][7] = 4;
        imageGrid[6][7] = 4;
        imageGrid[7][7] = 4;
        imageGrid[8][7] = 4;
        imageGrid[9][7] = 4;

        imageGrid[0][6] = 4;
        imageGrid[1][6] = 4;
        imageGrid[2][6] = 4;
        imageGrid[3][6] = 4;
        imageGrid[4][6] = 4;
        imageGrid[5][6] = 4;
        imageGrid[6][6] = 4;
        imageGrid[7][6] = 4;
        imageGrid[8][6] = 4;

        imageGrid[2][5] = 4;
        imageGrid[3][5] = 4;
        imageGrid[4][5] = 4;
        imageGrid[5][5] = 4;

        imageGrid[0][18] = 4;
        imageGrid[1][18] = 4;
        imageGrid[3][18] = 4;

        imageGrid[0][17] = 4;
        imageGrid[1][17] = 4;
        imageGrid[2][17] = 4;
        imageGrid[3][17] = 4;
        imageGrid[4][17] = 4;
        imageGrid[5][17] = 4;

        imageGrid[0][16] = 4;
        imageGrid[1][16] = 4;
        imageGrid[2][16] = 4;
        imageGrid[3][16] = 4;
        imageGrid[4][16] = 4;
        imageGrid[5][16] = 4;

        imageGrid[2][15] = 4;

        imageGrid[1][14] = 4;
        imageGrid[2][14] = 4;

        imageGrid[0][13] = 4;

        imageGrid[8][9] = 4;

        // Setting up the cells that has the weight 5
        imageGrid[19][6] = 5;

        imageGrid[11][6] = 5;
        imageGrid[11][5] = 5;
        imageGrid[12][5] = 5;
        imageGrid[19][5] = 5;

        imageGrid[12][4] = 5;
        imageGrid[13][4] = 5;
        imageGrid[14][4] = 5;
        imageGrid[19][4] = 5;
        imageGrid[18][4] = 5;
        imageGrid[17][4] = 5;

        imageGrid[13][3] = 5;
        imageGrid[14][3] = 5;
        imageGrid[15][3] = 5;
        imageGrid[16][3] = 5;
        imageGrid[17][3] = 5;
        imageGrid[18][3] = 5;
        imageGrid[19][3] = 5;

        imageGrid[13][2] = 5;
        imageGrid[14][2] = 5;
        imageGrid[15][2] = 5;
        imageGrid[16][2] = 5;
        imageGrid[17][2] = 5;
        imageGrid[18][2] = 5;
        imageGrid[19][2] = 5;

        imageGrid[11][1] = 5;
        imageGrid[12][1] = 5;
        imageGrid[13][1] = 5;
        imageGrid[14][1] = 5;
        imageGrid[15][1] = 5;
        imageGrid[16][1] = 5;
        imageGrid[17][1] = 5;
        imageGrid[18][1] = 5;
        imageGrid[19][1] = 5;

        imageGrid[11][0] = 5;
        imageGrid[12][0] = 5;
        imageGrid[13][0] = 5;
        imageGrid[14][0] = 5;
        imageGrid[15][0] = 5;
        imageGrid[16][0] = 5;
        imageGrid[17][0] = 5;
        imageGrid[18][0] = 5;
        imageGrid[19][0] = 5;

        showTheGrid();
    }

    private void generateThe20Grid() {
        imageGrid = new int[20][20];

        try {
            Scanner x = new Scanner(new File("landscape.txt"));

            while (x.hasNext()) {
                for (int i = imageGrid.length - 1; i > -1; i--) {
                    for (int j = 0; j < imageGrid.length; j++) {
                        imageGrid[j][i] = Integer.parseInt(x.next());
                    }
                }
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(MyPathFinder.class.getName()).log(Level.SEVERE, null, ex);
        }

        for (int i = imageGrid.length - 1; i > -1; i--) {
            for (int j = 0; j < imageGrid.length; j++) {

                System.out.print(imageGrid[j][i] + "\t");
            }
            System.out.println("\n");
        }

        showTheGrid();

    }

    private void generateThe40Grid() {
        imageGrid = new int[40][40];

        try {
            Scanner x = new Scanner(new File("landscape40.txt"));

            while (x.hasNext()) {
                for (int i = imageGrid.length - 1; i > -1; i--) {
                    for (int j = 0; j < imageGrid.length; j++) {
                        imageGrid[j][i] = Integer.parseInt(x.next());
                    }
                }
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(MyPathFinder.class.getName()).log(Level.SEVERE, null, ex);
        }

        for (int i = imageGrid.length - 1; i > -1; i--) {
            for (int j = 0; j < imageGrid.length; j++) {

                System.out.print(imageGrid[j][i] + "\t");
            }
            System.out.println("\n");
        }

        showTheGrid();

    }

    private void generateThe80Grid() {
        imageGrid = new int[80][80];

        try {
            Scanner x = new Scanner(new File("landscape80.txt"));

            while (x.hasNext()) {
                for (int i = imageGrid.length - 1; i > -1; i--) {
                    for (int j = 0; j < imageGrid.length; j++) {
                        imageGrid[j][i] = Integer.parseInt(x.next());
                    }
                }
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(MyPathFinder.class.getName()).log(Level.SEVERE, null, ex);
        }

        for (int i = imageGrid.length - 1; i > -1; i--) {
            for (int j = 0; j < imageGrid.length; j++) {

                System.out.print(imageGrid[j][i] + "\t");
            }
            System.out.println("\n");
        }

        showTheGrid();
    }

    // the purpose of this method is to render the grid based on their colors
    private void showTheGrid() {
        //StdDraw.setCanvasSize(700, 700);
        StdDraw.setYscale(-1, N);
        StdDraw.setXscale(-1, N);
        // visualising the grid in a window to make it easy for the user to pin point the origination and the destination.
        for (int i = imageGrid.length - 1; i > -1; i--) {
            for (int j = 0; j < imageGrid.length; j++) {
                if (imageGrid[j][i] == 2) {
                    StdDraw.setPenColor(StdDraw.LIGHT_GRAY);
                    StdDraw.filledSquare(j, i, 0.5);
                    StdDraw.setPenColor(StdDraw.BLACK);
                    StdDraw.text(j, i, "2");
                } else if (imageGrid[j][i] == 3) {
                    StdDraw.setPenColor(Color.GRAY);
                    StdDraw.filledSquare(j, i, 0.5);
                    StdDraw.setPenColor(StdDraw.WHITE);
                    StdDraw.text(j, i, "3");
                } else if (imageGrid[j][i] == 4) {
                    StdDraw.setPenColor(Color.DARK_GRAY);
                    StdDraw.filledSquare(j, i, 0.5);
                    StdDraw.setPenColor(StdDraw.WHITE);
                    StdDraw.text(j, i, "4");
                } else if (imageGrid[j][i] == 5) {
                    StdDraw.setPenColor(Color.BLACK);
                    StdDraw.filledSquare(j, i, 0.5);
                } else if (imageGrid[j][i] == 1) {
                    StdDraw.setPenColor(Color.BLACK);
                    StdDraw.square(j, i, 0.5);
                    StdDraw.setPenColor(Color.BLACK);
                    StdDraw.text(j, i, "1");
                }
            }
        }
    }

    private void showThePath(int origin_x, int origin_y, int desti_x, int desti_y, String user_selected_method) {

        // at the beginning of the process of findingThePath all the ArrayList will be cleared.
        openList.clear();
        closeList.clear();
        adjacentNodesList.clear();

        StdDraw.clear(Color.WHITE);

        showTheGrid();

        StdDraw.setPenColor(Color.BLUE);
        StdDraw.filledCircle(origin_x, origin_y, 0.5);

        StdDraw.setPenColor(Color.GREEN);
        StdDraw.filledCircle(desti_x, desti_y, 0.5);

        findingThePath(origin_x, origin_y, desti_x, desti_y, user_selected_method);

    }

    public void findingThePath(int origin_x, int origin_y, int desti_x, int desti_y, String userDefinedHeuristicMethod) {

        double hCost = 0;
        double gCost = 0;
        double fCost = 0;

        String heuristicMethod = userDefinedHeuristicMethod;

        if (heuristicMethod.equals("Euclidean")) {

            hCost = Math.sqrt(Math.pow((desti_x - origin_x), 2) + Math.pow((desti_y - origin_y), 2));

        } else if (heuristicMethod.equals("Manhattan")) {
            hCost = (Math.abs(desti_x - origin_x) + Math.abs(desti_y - origin_y));

        } else if (heuristicMethod.equals("Chebyshev")) {
            hCost = Math.max(Math.abs(desti_x - origin_x), Math.abs(desti_y - origin_y));
        }

        fCost = gCost + hCost;
        GraphNode startingNode = new GraphNode(origin_x, origin_y, hCost, gCost, fCost);

        openList.add(startingNode);

        //GraphNode currentNode;
        do {

            GraphNode currentNode = nodeWithLowestFCost();
            closeList.add(currentNode);

            openList.remove(currentNode);

            // this is checking if the destination node is in the close list. If it is there finding path process is stopped since it has already been found. 
            if (checkIfTheDestiNodeInTheCloseList(desti_x, desti_y)) {
                break;
            }

            checkingTheAdjacentCells(currentNode);

            for (GraphNode adjacentNode : adjacentNodesList) {
                boolean shouldContinue = false;

                for (GraphNode closeListNode : closeList) {
                    if (closeListNode.getxValue() == adjacentNode.getxValue() && closeListNode.getyValue() == adjacentNode.getyValue()) {
                        shouldContinue = true;// checking if the current adjacent node is already in the closedList. if it is already in the list then assign true.
                        break;
                    }

                }

                if (shouldContinue) {
                    // continue if the current checking adjacent node is already in the closedList.
                    continue;
                }

                boolean isItInOpenList = false;

                GraphNode adjacentInOpenList = null;

                for (GraphNode openListNode : openList) {
                    if (openListNode.getxValue() == adjacentNode.getxValue() && openListNode.getyValue() == adjacentNode.getyValue()) {
                        isItInOpenList = true;// This is checking if the current checking adjacent node is in the openList. If the openList already has it then assign
                        // true to it.
                        adjacentInOpenList = openListNode;
                        break;
                    }
                }

                /**
                 * if this condition return false that means that means the
                 * current checking adjacent node is already in the openList.
                 * then do not add the current adjacent node into the openList.
                 *
                 * if this condition return true that means the current adjacent
                 * node is not in the openList. Then compute its hCost, gCost
                 * and fCost and then add it to the openList.
                 */
                if (!(isItInOpenList)) {
                    if (heuristicMethod.equals("Euclidean")) {
                        hCost = Math.sqrt(Math.pow((desti_x - adjacentNode.getxValue()), 2) + Math.pow((desti_y - adjacentNode.getyValue()), 2));

                    } else if (heuristicMethod.equals("Manhattan")) {
                        hCost = (Math.abs(desti_x - adjacentNode.getxValue()) + Math.abs(desti_y - adjacentNode.getyValue()));

                    } else if (heuristicMethod.equals("Chebyshev")) {
                        hCost = Math.max(Math.abs(desti_x - adjacentNode.getxValue()), Math.abs(desti_y - adjacentNode.getyValue()));
                    }

                    gCost = currentNode.getgCost() + imageGrid[adjacentNode.getxValue()][adjacentNode.getyValue()];
                    fCost = gCost + hCost;

                    adjacentNode.setfCost(fCost);
                    adjacentNode.setgCost(gCost);
                    adjacentNode.sethCost(hCost);
                    adjacentNode.setParent(currentNode);

                    openList.add(adjacentNode);
                } else {
                    /**
                     * In this false block the current adjacent node's fCost
                     * will be compared with the fCost of the GraphNode object
                     * that is already in the openList that is equal to the
                     * current adjacent node.
                     *
                     *
                     * fCost of the current adjacent node will be assigned to
                     * the fCost of the GraphNode that is in the openList. that
                     * happens only if the fCost of the current adjacent node is
                     * less than the fCost of the GraphNode that it is equal to.
                     */

                    if (heuristicMethod.equals("Euclidean")) {
                        hCost = Math.sqrt(Math.pow((desti_x - adjacentNode.getxValue()), 2) + Math.pow((desti_y - adjacentNode.getyValue()), 2));

                    } else if (heuristicMethod.equals("Manhattan")) {
                        hCost = (Math.abs(desti_x - adjacentNode.getxValue()) + Math.abs(desti_y - adjacentNode.getyValue()));

                    } else if (heuristicMethod.equals("Chebyshev")) {
                        hCost = Math.max(Math.abs(desti_x - adjacentNode.getxValue()), Math.abs(desti_y - adjacentNode.getyValue()));
                    }

                    gCost = currentNode.getgCost() + imageGrid[adjacentNode.getxValue()][adjacentNode.getyValue()];
                    fCost = gCost + hCost;

                    if (fCost < adjacentInOpenList.getfCost()) {
                        adjacentInOpenList.sethCost(hCost);
                        adjacentInOpenList.setgCost(gCost);
                        adjacentInOpenList.setfCost(fCost);
                        adjacentInOpenList.setParent(currentNode);
                    }

                    

                }
            }

        } while (!openList.isEmpty());
        
        lblCoordinates.setText("---Coordinates---");
        lblOriginCoordinates.setText("Origination : " + "(" + origin_x + "," + origin_y + ")");
        lblDestiCoordinates.setText("Destination : " + "(" + desti_x + "," + desti_y + ")");

        lblHMethodTopic.setText("---Selected Heuristic Method---");
        lblHMethod.setText(heuristicMethod);

        lblTotalCostTopic.setText("---Total Cost Of the Path---");

        GraphNode theNode = closeList.get(closeList.size() - 1).getParent();

        lblTotalCost.setText("" + closeList.get(closeList.size() - 1).getgCost());

        while (!(theNode.getxValue() == origin_x && theNode.getyValue() == origin_y)) {

            StdDraw.setPenColor(Color.RED);
            StdDraw.filledCircle(theNode.getxValue(), theNode.getyValue(), 0.3);

            theNode = theNode.getParent();
        }

    }

    // This method is used to go throught the openlist to find the GraphNode object with the lowest fCost.
    public GraphNode nodeWithLowestFCost() {

        // assigning the fCost of the first object of the openList to this variable.
        double minFCost = openList.get(0).getfCost();

        GraphNode nodeWithTheLowestFCost = null;

        // checking if the fCost of the object in the openList less minFCost.
        for (GraphNode nodeObj : openList) {
            if (nodeObj.getfCost() <= minFCost) {//testing ended here
                minFCost = nodeObj.getfCost();
                nodeWithTheLowestFCost = nodeObj;
            }
        }

        // returning the object with the lowest fCost.
        return nodeWithTheLowestFCost;
    }

    // This method will look for all the adjacent cell around the current cell and add them to the arraylist of adjacentNodesList.
    public void checkingTheAdjacentCells(GraphNode currentNode) {
        adjacentNodesList.clear();

        // this is adding the west direction adjacent node to the current node to the adjacentList.
        if (currentNode.getxValue() - 1 >= 0) {
            if (!(imageGrid[currentNode.getxValue() - 1][currentNode.getyValue()] == 5)) {
                GraphNode westAdjacentNode = new GraphNode(currentNode.getxValue() - 1, currentNode.getyValue());
                adjacentNodesList.add(westAdjacentNode);
            }

            // this is adding the north west direction adjacent node to the current node to the adjacentList.
            if (currentNode.getyValue() + 1 < imageGrid.length) {
                if (!(imageGrid[currentNode.getxValue() - 1][currentNode.getyValue() + 1] == 5)) {
                    GraphNode northWestAdjacentNode = new GraphNode(currentNode.getxValue() - 1, currentNode.getyValue() + 1);
                    adjacentNodesList.add(northWestAdjacentNode);
                }

            }

            // this is adding the south west direction adjacent node to the current node to the adjacentList.
            if (currentNode.getyValue() - 1 >= 0) {
                if (!(imageGrid[currentNode.getxValue() - 1][currentNode.getyValue() - 1] == 5)) {
                    GraphNode southWestAdjacentNode = new GraphNode(currentNode.getxValue() - 1, currentNode.getyValue() - 1);
                    adjacentNodesList.add(southWestAdjacentNode);
                }

            }
        }

        // this is adding the sount direction adjacent node to the current node to the adjacentList.
        if (currentNode.getyValue() - 1 >= 0) {
            if (!(imageGrid[currentNode.getxValue()][currentNode.getyValue() - 1] == 5)) {
                GraphNode southAdjacentNode = new GraphNode(currentNode.getxValue(), currentNode.getyValue() - 1);
                adjacentNodesList.add(southAdjacentNode);
            }

        }

        // this is adding the north direction adjacent node to the current node to the adjacentList.
        if (currentNode.getyValue() + 1 < imageGrid.length) {
            if (!(imageGrid[currentNode.getxValue()][currentNode.getyValue() + 1] == 5)) {
                GraphNode northAdjacentNode = new GraphNode(currentNode.getxValue(), currentNode.getyValue() + 1);
                adjacentNodesList.add(northAdjacentNode);
            }

        }

        // this is adding the east direction adjacent node to the current node to the adjacentList.
        if (currentNode.getxValue() + 1 < imageGrid.length) {
            if (!(imageGrid[currentNode.getxValue() + 1][currentNode.getyValue()] == 5)) {
                GraphNode eastAdjacentNode = new GraphNode(currentNode.getxValue() + 1, currentNode.getyValue());
                adjacentNodesList.add(eastAdjacentNode);
            }

            // this is adding the south east direction adjacent node to the current node to the adjacentList.
            if (currentNode.getyValue() - 1 >= 0) {
                if (!(imageGrid[currentNode.getxValue() + 1][currentNode.getyValue() - 1] == 5)) {
                    GraphNode southEastAdjacentNode = new GraphNode(currentNode.getxValue() + 1, currentNode.getyValue() - 1);
                    adjacentNodesList.add(southEastAdjacentNode);
                }
            }

            // this is adding the north east direction adjacent node to the current node to the adjacentList.
            if (currentNode.getyValue() + 1 < imageGrid.length) {
                if (!(imageGrid[currentNode.getxValue() + 1][currentNode.getyValue() + 1] == 5)) {
                    GraphNode northEastAdjacentNode = new GraphNode(currentNode.getxValue() + 1, currentNode.getyValue() + 1);
                    adjacentNodesList.add(northEastAdjacentNode);
                }

            }
        }

    }

    // This method is to check if the destination node is in the close list. if it is there this method will return a boolean true value.
    public boolean checkIfTheDestiNodeInTheCloseList(int destiX, int destiY) {
        boolean isItThere = false;

        for (GraphNode nodeObj : closeList) {
            if ((nodeObj.getxValue() == destiX) && (nodeObj.getyValue() == destiY)) {
                isItThere = true;
            } else {
                isItThere = false;
            }
        }

        return isItThere;
    }

    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MyPathFinder.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MyPathFinder.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MyPathFinder.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MyPathFinder.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MyPathFinder().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox CBMethod;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JLabel lblCoordinates;
    private javax.swing.JLabel lblDestiCoordinates;
    private javax.swing.JLabel lblHMethod;
    private javax.swing.JLabel lblHMethodTopic;
    private javax.swing.JLabel lblOriginCoordinates;
    private javax.swing.JLabel lblTopic;
    private javax.swing.JLabel lblTotalCost;
    private javax.swing.JLabel lblTotalCostTopic;
    private javax.swing.JTextField txt_desti_x;
    private javax.swing.JTextField txt_desti_y;
    private javax.swing.JTextField txt_origin_x;
    private javax.swing.JTextField txt_origin_y;
    // End of variables declaration//GEN-END:variables
}
